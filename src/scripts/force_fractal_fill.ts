import { connectDB } from '../config/db';
import { connectRedis } from '../config/redis';
import { CandleService } from '../modules/market/candle.service';
import { fetchCurrentPrice } from '../modules/market/market.service';
import Instrument from '../modules/market/instrument.model';
import logger from '../common/utils/logger';

// Mute logger
logger.level = 'info';

const run = async () => {
  try {
    console.log('Initializing...');
    await connectDB();
    await connectRedis();

    const candleService = new CandleService();
    
    // We want to force a fix for ALL crypto instruments to overwrite potential bad synthetic data
    // with the new high-quality fractal data.
    const instruments = await Instrument.find({ isEnabled: true });
    console.log('Found ' + instruments.length + ' enabled instruments.');

    // Look back 48 hours for history to clone
    const lookbackMs = 48 * 60 * 60 * 1000;

    for (const inst of instruments) {
        console.log('\n--------------------------------------------------');
        console.log('Processing ' + inst.symbol + '...');

        // 1. Fetch current price to define the target of our gap fill
        const currentPrice = await fetchCurrentPrice(inst.symbol);
        
        if (currentPrice) {
             console.log('  Current Price: ' + currentPrice);
             
             // 2. Trigger the new Fractal Gap Filler
             // This will look for history, clone it, adapt it to the current price, 
             // and overwrite any existing synthetic data in that range (due to upsert logic).
             // To ensure we overwrite "bad" recent synthetic data, we might need to be aggressive.
             // The fillDataGaps function automatically finds the last candle. 
             // If the last candle IS synthetic and recent, we might want to delete it first 
             // to force a refill from a real historical point. 
             
             // For this script, let's trust the gap filler's logic to find the last candle.
             // If the last candle is "real" (from 10 hours ago), it fills forward.
             // If the last candle is "synthetic" (from 1 minute ago, generated by old logic), 
             // it won't see a gap!
             
             // CRITICAL: Check if recent data is synthetic and purge it if we want to "fix" it.
             // For now, let's just run the filler. If there's a gap, it uses the NEW logic.
             await candleService.fillDataGaps(inst.symbol, currentPrice);
             console.log('  ✅ Gap fill routine executed.');
        } else {
             console.log('  ⚠️ Could not fetch live price, skipping.');
        }
    }

    console.log('\n✅ All done. Fractal Gap Filler run complete.');
    process.exit(0);
  } catch (err) {
    console.error(err);
    process.exit(1);
  }
};

run();
